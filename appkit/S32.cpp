/*
 * Software by Thanh Phung -- thanhtphung@yahoo.com.
 * No copyrights. No warranties. No restrictions in reuse.
 */
#include <string.h>
#include "syskit/macros.h"

#include "appkit-pch.h"
#include "appkit/S32.hpp"
#include "appkit/U32.hpp"

//
// isXxx map.
// Indexed by EOF (-1) or unsigned char value.
// Generated using the following code.
//
// enum
// {
//   BlankM=0x01, CntrlM=0x02, DigitM=0x04, LowerM=0x08,
//   PunctM=0x10, SpaceM=0x20, UpperM=0x40, XdigitM=0x80
// };
//
// unsigned char map[257] = {0};
// unsigned char* m = &map[1];
// m[' '] |= BlankM;
// for (unsigned int i=0x00U; i<=0x1fU; m[i++]|=CntrlM); m[0x7fU] |= CntrlM;
// for (unsigned int i='0'; i<='9'; m[i++]|=DigitM);
// for (unsigned int i='a'; i<='z'; m[i++]|=LowerM);
// for (unsigned int i='!'; i<='/'; m[i++]|=PunctM);
// for (unsigned int i=':'; i<='@'; m[i++]|=PunctM);
// for (unsigned int i='['; i<='`'; m[i++]|=PunctM);
// for (unsigned int i='{'; i<='~'; m[i++]|=PunctM);
// for (unsigned int i=0x09U; i<=0x0dU; m[i++]|=SpaceM); m[' '] |= SpaceM;
// for (unsigned int i='A'; i<='Z'; m[i++]|=UpperM);
// for (unsigned int i='a'; i<='f'; m[i++]|=XdigitM);
// for (unsigned int i='A'; i<='F'; m[i++]|=XdigitM);
// for (unsigned int i='0'; i<='9'; m[i++]|=XdigitM);
//
// printf("\n  0x%02xU,\n", m[-1]);
// for (unsigned int i=0, j=8; i<256; i=j, j+=8)
// {
//   printf(" ");
//   for (unsigned int k=i; k<j; ++k) printf(" 0x%02xU,", m[k]);
//   printf(" //0x%02x-0x%02x\n", i, j-1);
// }
//
static const unsigned char s_mask[] =
{
    0x00U,
    0x02U, 0x02U, 0x02U, 0x02U, 0x02U, 0x02U, 0x02U, 0x02U, //0x00-0x07
    0x02U, 0x22U, 0x22U, 0x22U, 0x22U, 0x22U, 0x02U, 0x02U, //0x08-0x0f
    0x02U, 0x02U, 0x02U, 0x02U, 0x02U, 0x02U, 0x02U, 0x02U, //0x10-0x17
    0x02U, 0x02U, 0x02U, 0x02U, 0x02U, 0x02U, 0x02U, 0x02U, //0x18-0x1f
    0x21U, 0x10U, 0x10U, 0x10U, 0x10U, 0x10U, 0x10U, 0x10U, //0x20-0x27
    0x10U, 0x10U, 0x10U, 0x10U, 0x10U, 0x10U, 0x10U, 0x10U, //0x28-0x2f
    0x84U, 0x84U, 0x84U, 0x84U, 0x84U, 0x84U, 0x84U, 0x84U, //0x30-0x37
    0x84U, 0x84U, 0x10U, 0x10U, 0x10U, 0x10U, 0x10U, 0x10U, //0x38-0x3f
    0x10U, 0xc0U, 0xc0U, 0xc0U, 0xc0U, 0xc0U, 0xc0U, 0x40U, //0x40-0x47
    0x40U, 0x40U, 0x40U, 0x40U, 0x40U, 0x40U, 0x40U, 0x40U, //0x48-0x4f
    0x40U, 0x40U, 0x40U, 0x40U, 0x40U, 0x40U, 0x40U, 0x40U, //0x50-0x57
    0x40U, 0x40U, 0x40U, 0x10U, 0x10U, 0x10U, 0x10U, 0x10U, //0x58-0x5f
    0x10U, 0x88U, 0x88U, 0x88U, 0x88U, 0x88U, 0x88U, 0x08U, //0x60-0x67
    0x08U, 0x08U, 0x08U, 0x08U, 0x08U, 0x08U, 0x08U, 0x08U, //0x68-0x6f
    0x08U, 0x08U, 0x08U, 0x08U, 0x08U, 0x08U, 0x08U, 0x08U, //0x70-0x77
    0x08U, 0x08U, 0x08U, 0x10U, 0x10U, 0x10U, 0x10U, 0x02U, //0x78-0x7f
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0x80-0x87
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0x88-0x8f
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0x90-0x97
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0x98-0x9f
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0xa0-0xa7
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0xa8-0xaf
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0xb0-0xb7
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0xb8-0xbf
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0xc0-0xc7
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0xc8-0xcf
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0xd0-0xd7
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0xd8-0xdf
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0xe0-0xe7
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0xe8-0xef
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, //0xf0-0xf7
    0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U  //0xf8-0xff
};

BEGIN_NAMESPACE1(appkit)

// toLower map (0x41U=='A', 0x5aU=='Z', 0x61U=='a', 0x7aU=='z').
// Indexed by ASCII value.
// If i is not an uppercase letter, lower_[i]==i.
// Otherwise, lower_[i]==lowercase(i).
const char S32::lower_[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, //0x00-0x07
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, //0x08-0x0f
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, //0x10-0x17
    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, //0x18-0x1f
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, //0x20-0x27
    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, //0x28-0x2f
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, //0x30-0x37
    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, //0x38-0x3f
    0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, //0x40-0x47
    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, //0x48-0x4f
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, //0x50-0x57
    0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, //0x58-0x5f
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, //0x60-0x67
    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, //0x68-0x6f
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, //0x70-0x77
    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f  //0x78-0x7f
};

// toUpper map (0x41U=='A', 0x5aU=='Z', 0x61U=='a', 0x7aU=='z').
// Indexed by ASCII value.
// If i is not a lowercase letter, upper_[i]==i.
// Otherwise, upper_[i]==uppercase(i).
const char S32::upper_[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, //0x00-0x07
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, //0x08-0x0f
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, //0x10-0x17
    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, //0x18-0x1f
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, //0x20-0x27
    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, //0x28-0x2f
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, //0x30-0x37
    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, //0x38-0x3f
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, //0x40-0x47
    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, //0x48-0x4f
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, //0x50-0x57
    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, //0x58-0x5f
    0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, //0x60-0x67
    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, //0x68-0x6f
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, //0x70-0x77
    0x58, 0x59, 0x5a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f  //0x78-0x7f
};

const unsigned char* const S32::mask_ = &s_mask[1];


S32::S32(const String* s, item_t defaultV)
{
    if ((s == 0) || s->empty())
    {
        v_ = defaultV;
    }
    else
    {
        char* pEnd;
        const char* p = s->ascii();
        item_t v = std::strtol(p, &pEnd, 0);
        v_ = ((pEnd != p) && (*pEnd == 0))? v: defaultV;
    }
}


//!
//! Return instance as a decimal string.
//!
String S32::toString() const
{
    char digit[U32::MaxDigits + 1];
    size_t n;
    unsigned int v;
    if (v_ < 0)
    {
        digit[0] = '-';
        n = 1;
        v = -v_;
    }
    else
    {
        n = 0;
        v = v_;
    }

    n += U32::toDigits(v, digit + n);
    return String(digit, n);
}


S32::item_t S32::toS32(const char* s, size_t length, size_t* bytesUsed)
{
    const size_t MAX_LENGTH = 127;
    char* pEnd;
    item_t c;
    item_t v;
    if ((length <= 0) || (length > MAX_LENGTH))
    {
        v = 0;
        *bytesUsed = 0;
    }

    else if (((c = s[length - 1]) == 0) || S32::isSpace(c))
    {
        v = std::strtol(s, &pEnd, 0);
        *bytesUsed = pEnd - s;
    }

    // Use stack for temporary null-terminated string copy.
    else
    {
        char buf[MAX_LENGTH + 1];
        memcpy(buf, s, length);
        buf[length] = 0;
        v = std::strtol(buf, &pEnd, 0);
        *bytesUsed = pEnd - buf;
    }

    return v;
}


//!
//! Return true if given string (length characters starting at s) holds a signed
//! 32-bit number and nothing else.
//!
bool S32::isValid(const char* s, size_t length)
{
    const size_t MAX_LENGTH = 127;
    if ((length <= 0) || (length > MAX_LENGTH))
    {
        return false;
    }

    char* pEnd;
    item_t c = s[length - 1];
    if ((c == 0) || S32::isSpace(c))
    {
        std::strtol(s, &pEnd, 0);
        return (pEnd == (s + length - 1));
    }

    // Use stack for temporary null-terminated string copy.
    char buf[MAX_LENGTH + 1];
    memcpy(buf, s, length);
    buf[length] = 0;
    std::strtol(buf, &pEnd, 0);
    return (pEnd == (buf + length));
}

END_NAMESPACE1
